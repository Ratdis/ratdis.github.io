<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="ratdis,ratdis1@gmail.com"><title>使用Flask-SQLAlchemy管理数据库 · 墨染的樱花🌸</title><meta name="description" content="写在前面想了想，笔记这个表述还是太过于笼统了，单独拎出来也方便查询复盘
这里我们只是涉及到Flask-SQLAlchemy的使用层次上，深入的架构关系处理按下不表
以下内容参考Flask+Web开发实战抄，是本好书，感谢作者
初始配置
安装

1&amp;gt; pip install flask-sqlc"><meta name="keywords" content="Hexo,HTML,CSS,Android,Linux,Python"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">墨染的樱花🌸</a></h3><div class="description"><p>成就今日 启迪未来</p></div></div></div><ul class="social-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>使用Flask-SQLAlchemy管理数据库</a></h3></div><div class="post-content"><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>想了想，笔记这个表述还是太过于笼统了，单独拎出来也方便查询复盘</p>
<p>这里我们只是涉及到Flask-SQLAlchemy的使用层次上，深入的架构关系处理按下不表</p>
<p>以下内容参考Flask+Web开发实战<del>抄</del>，是本好书，感谢作者</p>
<h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><ol>
<li>安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> pip install flask-sqlclchemy</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>实例化Flask-SQLAlchemy提供的SQLAlchemy类，传入程序 实例app，以完成扩展的初始化:</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">db = SQLAlchemy(app)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>连接数据库服务器<img src="Screen Shot 2020-02-21 at 5.00.44 PM.png" alt="Screen Shot 2020-02-21 at 5.00.44 PM"></li>
</ol>
<p>配置SQLite数据库URI</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> ...</span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_DATABASE_URI'</span>] = os.getenv(<span class="string">'DATABASE_URL'</span>, <span class="string">'sqlite:///'</span> + os.path.join(app.root_path, <span class="string">'db.sqlite3'</span>))</span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_TRACK_MODIFICATIONS'</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>这里图方便用的就是SQLite，只需要提供文件路径即可[这里是app同路径下db.sqlite3]，但在生产环境下更换到其他类型的DBMS时，数据库URL会包含敏感信息，所以这里优先从环境变量DATABASE_URL获取，【注意不同操作系统下斜杆数不一致】所以也就玩具项目图方便用下，其他情况下还是用Mysql等更专业的吧</p>
<p>配置Mysql数据库URI</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> ...</span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_DATABASE_URI'</span>] = os.getenv(<span class="string">'DATABASE_URL'</span>,<span class="string">'mysql://root:password@127.0.0.1:3306/database_name'</span>)</span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_TRACK_MODIFICATIONS'</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>需要提前开启Mysql服务器以及创建好database_name</p>
<p>安装并初始化Flask-SQLAlchemy后，启动程序时会看到命令行下有一行警告信息。这是因为Flask-SQLAlchemy建议你设置SQLALCHEMY_TRACK_MODIFICATIONS 配置变量，这个配置变量决定是否追踪对象的修改，这用于Flask-SQLAlchemy的事 件通知系统。这个配置键的默认值为None，如果没有特殊需要，我们可以把它设为 False来关闭警告信息:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config[<span class="string">'SQLALCHEMY_TRACK_MODIFICATIONS'</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="定义数据库模型"><a href="#定义数据库模型" class="headerlink" title="定义数据库模型"></a>定义数据库模型</h3><p><img src="Screen Shot 2020-02-22 at 9.06.12 AM.png" alt="Screen Shot 2020-02-22 at 9.06.12 AM"></p>
<p><img src="Screen Shot 2020-02-22 at 9.12.31 AM.png" alt="Screen Shot 2020-02-22 at 9.12.31 AM">这里我就演示了下几个常用的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"> ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    author = db.Column(db.String(<span class="number">25</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    created_time = db.Column(db.DateTime, default=datetime.now, nullable = <span class="literal">False</span>)</span><br><span class="line">    body = db.Column(db.Text,default=<span class="string">'Write Something'</span>)</span><br></pre></td></tr></table></figure>
<p>默认情况下，Flask-SQLAlchemy会根据模型类的名称生成一个表名称，生成规则如下:</p>
<p>Message –&gt; message # 单个单词转换为小写<br> FooBar –&gt; foo_bar # 多个单词转换为小写并使用下划线分隔</p>
<p>Note类对应的表名称即note。如果你想自己指定表名称，可以通过定义 <code>__tablename__</code>属性来实现。</p>
<h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><p>定义好模型后就可以直接创建了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line"> ...</span><br><span class="line"><span class="meta">@app.cli.command()</span></span><br><span class="line"><span class="meta">@click.option('--drop', is_flag=True, help='Create after drop.')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initdb</span><span class="params">(drop)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> drop:</span><br><span class="line">        click.confirm(<span class="string">'This operation will delete the database, do you want to continue?'</span>, abort=<span class="literal">True</span>)</span><br><span class="line">        db.drop_all()</span><br><span class="line">        click.echo(<span class="string">'Drop tables.'</span>)</span><br><span class="line">    db.create_all()</span><br><span class="line">    click.echo(<span class="string">'Initialized database.'</span>)</span><br></pre></td></tr></table></figure>
<p>这里自定义了个flask命令<code>flask initdb</code>，用click还添加了个<code>--drop</code>的参数</p>
<p>但是我们这里为了让数据库中实际的表同步数据模型的变化【添加或删除字段，修改字段的名称和类型之类的】是直接暴力的db.drop_all()后再重新db.create_all()，会直接清空表中原有的数据，迁移表原有数据后文中写</p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>为了方便，接下来使用flask shell进行演示，在此之前我们先将自己定义的数据库模型类以及db手动传入到上下文中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传入shell上下文</span></span><br><span class="line"><span class="meta">@app.shell_context_processor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_shell_context</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> dict(db=db, Note=Note)</span><br></pre></td></tr></table></figure>
<p>终端进入项目所在路径执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> flask initdb --drop</span><br><span class="line">This operation will delete the database, do you want to continue? [y/N]: y</span><br><span class="line">Drop tables.</span><br><span class="line">Initialized database.</span><br><span class="line"><span class="meta">&gt;</span> flask shell</span><br><span class="line">Python 3.7.5 (default, Nov 29 2019, 17:17:51) </span><br><span class="line">[Clang 11.0.0 (clang-1100.0.20.17)] on darwin</span><br><span class="line">App: app [production]</span><br><span class="line">Instance: /Users/Mosaic/Programming/Flask/instance</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>用上一小节的命令<code>flask initdb --drop</code>我们先同步好了模型表，然后进入<code>flask shell</code></p>
<p>【<strong>下文中<code>&gt;&gt;&gt;</code>开头的都代表是在flask shell模式中</strong>】</p>
<p>增删改查</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>note1 = Note(body=<span class="string">'hello'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>note2 = Note(body=<span class="string">'world'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.add(note1) <span class="comment"># 增</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.add(note2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.commit() <span class="comment"># 每次更改都要commit才能同步到数据库</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.delete(note1) <span class="comment"># 删</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.commit()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>note1.body = <span class="string">'giao!'</span> <span class="comment"># 改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.session.commit()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Note.query.filter_by(body=<span class="string">'giao!'</span>).first() == note1 <span class="comment"># 查</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>一般来说，一个完整的查询遵循下面的模式: &lt;模型类&gt;.query.&lt;过滤方法&gt;.&lt;查询方法&gt;<img src="Screen Shot 2020-02-22 at 10.53.04 AM.png" alt="Screen Shot 2020-02-22 at 10.53.04 AM"></p>
<p><img src="Screen Shot 2020-02-22 at 10.53.27 AM.png" alt="Screen Shot 2020-02-22 at 10.53.27 AM"></p>
<p>和filter()方法相比，filter_by()方法更易于使用。在filter_by() 方法中，你可以使用关键字表达式来指定过滤规则。更方便的是，你可以在这个过 滤器中直接使用字段名称。下面的示例使用filter_by()过滤器完成了同样的任务:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Note.query.filter_by(body=<span class="string">'SHAVE'</span>).first()</span><br><span class="line"><span class="comment"># 等价于 Note.query.filter(Note.body='SHAVE').first()</span></span><br></pre></td></tr></table></figure>
<p>其他的不一一举例了</p>
<h3 id="建立模型之间几种基础的关系模式"><a href="#建立模型之间几种基础的关系模式" class="headerlink" title="建立模型之间几种基础的关系模式"></a>建立模型之间几种基础的关系模式</h3><p>本来只是想总结下这个知识点的…想想算了，还是写完整点吧</p>
<p>（1）单向和双向关系</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">70</span>), unique=<span class="literal">True</span>)</span><br><span class="line">    books = db.relationship(<span class="string">'Book'</span>, back_populates=<span class="string">'writer'</span>)</span><br><span class="line">    <span class="comment"># books = db.relationship('Book')</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = db.Column(db.String(<span class="number">50</span>), index=<span class="literal">True</span>)</span><br><span class="line">    writer_id = db.Column(db.Integer, db.ForeignKey(<span class="string">'writer.id'</span>)) </span><br><span class="line">    writer = db.relationship(<span class="string">'Writer'</span>, back_populates=<span class="string">'books'</span>)</span><br><span class="line">    <span class="comment"># writer = db.relationship('Writer')</span></span><br></pre></td></tr></table></figure>
<p>这里我们定义了两个模型，都定义了db.relationship</p>
<p>relationship()函数的第一个参数为关系另一侧的模型名称，在Writer中它会告诉 SQLAlchemy将Writer类与Book类建立关系</p>
<p>如果db.relationship只被定义在Writer中，而Book中没有，就叫单向关系【只能从Writer查询到books，不能从Book方向查询自己的Writer】，两边都有就是双向关系【双方可以互查】</p>
<p>而back_populates参数是用来连接两边的relationship的，值为对面关系名字，从而实现<strong>未commit之前</strong>两边关系的同步【例如删掉了Writer A的Book B，Book B的Writer A也会被同步删除】，但是不管加没加back_populates参数，commit之后两边关系总会同步好的【之所以加重<code>未commit之前</code>是因为自己一个个测试出来的…当初对back_populates这个参数有点疑惑<del>坑</del>，涉及到了后面的级联】</p>
<p>其他参数如下，不一一举例了，backref是隐式双向，不推荐，uselist可以用在一对一关系中，secondary用在多对多关系中</p>
<p><img src="Screen Shot 2020-02-22 at 4.54.13 PM.png" alt="Screen Shot 2020-02-22 at 4.54.13 PM"></p>
<p>【下面几种关系都默认使用双向关系】</p>
<p>（2）一对多/多对一</p>
<p>定义关系的第一步是创建外键。外键是(foreign key)用来在A表存储B表的主键值以便和B表建立联系的关系字段。因为外键只能存储单一数据(标量)，所以<strong>外键总是在“多”这一侧定义</strong>，多本书属于同一个作者，所以我们需要为每本书添加外键存储作者的主键值以指向对应的作者。在Book模型中，我们定义一 个writer_id字段作为外键:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">  ...</span><br><span class="line">writer_id = db.Column(db.Integer, db.ForeignKey(<span class="string">'writer.id'</span>))</span><br></pre></td></tr></table></figure>
<p>这个字段使用db.ForeignKey类定义为外键，传入关系另一侧的表名和主键字段名，即writer.id。实际的效果是将book表的writer_id的值限制为Writer表的id列的值。它将用来存储Writer表中记录的主键值</p>
<p>再加上双向关系，一个一对多/多对一就完成了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">70</span>), unique=<span class="literal">True</span>)</span><br><span class="line">    books = db.relationship(<span class="string">'Book'</span>, back_populates=<span class="string">'writer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = db.Column(db.String(<span class="number">50</span>), index=<span class="literal">True</span>)</span><br><span class="line">    writer_id = db.Column(db.Integer, db.ForeignKey(<span class="string">'writer.id'</span>)) </span><br><span class="line">    writer = db.relationship(<span class="string">'Writer'</span>, back_populates=<span class="string">'books'</span>)</span><br></pre></td></tr></table></figure>
<p>当Writer查询books时，会返回所有Book.writer_id与Writer.id一致的Book【返回列表】</p>
<p>而当Book查询Writer时，会返回Writer.id与writer_id一致的Writer【返回单个值】</p>
<p>（3）一对一</p>
<p>一对一就是再一对多/多对一的基础上加上了个参数，下面假设一个作者一生只写一本书，一本书也只能有一个作者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">70</span>), unique=<span class="literal">True</span>)</span><br><span class="line">    book = db.relationship(<span class="string">'Book'</span>, back_populates=<span class="string">'writer'</span>, uselist=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = db.Column(db.String(<span class="number">50</span>), index=<span class="literal">True</span>)</span><br><span class="line">    writer_id = db.Column(db.Integer, db.ForeignKey(<span class="string">'writer.id'</span>)) </span><br><span class="line">    writer = db.relationship(<span class="string">'Writer'</span>, back_populates=<span class="string">'books'</span>)</span><br></pre></td></tr></table></figure>
<p>在Writer的relationship加上了uselist=False，这将表示只能返回单个值了</p>
<p>（4）多对多</p>
<p>需要额外定义一个表来处理两边的外键对应关系</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">association_table = db.Table(<span class="string">'association'</span>,db.Column(<span class="string">'student_id'</span>, db.Integer, db.ForeignKey(<span class="string">'student.id'</span>)),db.Column(<span class="string">'teacher_id'</span>, db.Integer, db.ForeignKey(<span class="string">'teacher.id'</span>))</span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>) </span><br><span class="line">    name = db.Column(db.String(<span class="number">70</span>), unique=<span class="literal">True</span>) </span><br><span class="line">    grade = db.Column(db.String(<span class="number">20</span>))</span><br><span class="line">    teachers = db.relationship(<span class="string">'Teacher'</span>,</span><br><span class="line">    secondary=association_table, back_populates=<span class="string">'students'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>) </span><br><span class="line">    name = db.Column(db.String(<span class="number">70</span>), unique=<span class="literal">True</span>) </span><br><span class="line">    office = db.Column(db.String(<span class="number">20</span>))</span><br></pre></td></tr></table></figure>
<p><img src="Screen Shot 2020-02-22 at 5.43.28 PM.png" alt="Screen Shot 2020-02-22 at 5.43.28 PM"></p>
<h3 id="迁移数据库"><a href="#迁移数据库" class="headerlink" title="迁移数据库"></a>迁移数据库</h3><p>我们使用Flask-Migrate来实现保留数据更改表</p>
<p>1.安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> pip install flask-migrate</span><br></pre></td></tr></table></figure>
<p>2.实例化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"><span class="keyword">from</span> flask_migrate <span class="keyword">import</span> Migrate</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> ...</span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line">migrate = Migrate(app, db) <span class="comment"># 在db对象创建后调用</span></span><br></pre></td></tr></table></figure>
<p>3.创建迁移环境</p>
<p>在开始迁移数据之前，需要先使用下面的命令创建一个迁移环境:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> flask db init</span><br></pre></td></tr></table></figure>
<p>4.生成迁移脚本</p>
<p>使用migrate子命令可以自动生成迁移脚本:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> flask db migrate -m "add note timestamp"</span><br><span class="line">    ...</span><br><span class="line">INFO [alembic.autogenerate.compare] Detected added column 'message.timestamp</span><br><span class="line">Generating /Path/to/your/database/migrations/versions/c52a02014635_add note_timestamp.py ... done</span><br></pre></td></tr></table></figure>
<p>这条命令可以简单理解为在flask里对数据库(db)进行迁移(migrate)。</p>
<p>-m 选项用来添加迁移备注信息。</p>
<p>从上面的输出信息我们可以看到，Alembic检测出了 模型的变化:表note新添加了一个timestamp列，并且相应生成了一个迁移脚本 c52a02014635_add_note_timestamp.py</p>
<p>【迁移命令是由Alembic自动生成的，其中可能包含错误，所以有必要在生成后检查一下。】</p>
<p>因为每一次迁移都会生成新的迁移脚本，而且Alembic为每一次迁移都生成了修订版本(revision)ID，所以数据库可以恢复到修改历史中的任一点。正因为如此，迁移环境中的文件也要纳入版本控制。</p>
<p>有些复杂的操作无法实现自动迁移，这时可以使用revision命令手动创建迁移脚本。这同样会生成一个迁移脚本，不过脚本中的upgrade()和downgrade()函数都是空的。你需要使用Alembic提供的Operations对象指令在这两个函数中实现具体操作，具体可以访问Alembic官方文档查看。</p>
<p>5.更新数据库</p>
<p>生成了迁移脚本后，使用upgrade子命令即可更新数据库:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> flask db upgrade</span><br><span class="line"> ...</span><br><span class="line">INFO [alembic.runtime.migration] Running upgrade -&gt; c52a02014635, add note timestamp</span><br></pre></td></tr></table></figure>
<p>如果还没有创建数据库和表，这个命令会自动创建；如果已经创建，则会在不 损坏数据的前提下执行更新。</p>
<p>如果你想回滚迁移，那么可以使用downgrade命令(降级)，它会撤销最后一 次迁移在数据库中的改动，这在开发时非常有用。比如，当你执行upgrade命令后,发现某些地方出错了，这时就可以执行flask db downgrade命令进行回滚，删除对应的迁移脚本，重新生成迁移脚本后再进行更新(upgrade)。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>还有一些什么级联操作，事件监听之类的没有提到……</p>
<p>至少今天不想写了，写笔记的时间比学习内容时间都要多是好事还是坏事，emmmmm，不过思路还是清晰了，管他呢~ </p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-02-22</span><i class="fa fa-comment-o"></i><a href="/2020/02/22/use-Flask-SQLAlchemy-database management/#comments">Comments</a><i class="fa fa-tag"></i><a class="tag" href="/categories/Note/" title="Note">Note </a><a class="tag" href="/tags/Python/" title="Python">Python </a><a class="tag" href="/tags/Flask/" title="Flask">Flask </a><a class="tag" href="/tags/DataBase/" title="DataBase">DataBase </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://ratdis.github.io/2020/02/22/use-Flask-SQLAlchemy-database management/,墨染的樱花🌸,使用Flask-SQLAlchemy管理数据库,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/11/29/Python-virtual-environment-hodgepodge/" title="Python虚拟环境大杂烩">next_post</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'ratdis';
var disqus_identifier = '2020/02/22/use-Flask-SQLAlchemy-database management/';
var disqus_title = '使用Flask-SQLAlchemy管理数据库';
var disqus_url = 'https://ratdis.github.io/2020/02/22/use-Flask-SQLAlchemy-database management/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/baidu-statistical.js"></script></body></html>