<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="ratdis,ratdis1@gmail.com"><title>用Python写个小Bot · 墨染的樱花🌸</title><meta name="description" content="写在前面正如你所看到的，这篇文章我们来学习一下用Python玩下Telegram中的Bot吧
实现一个实时查询服务器CPU利用率的Bot

Wikipedia:
Telegram是一个跨平台的即时通信软件，它的客户端是自由及开放源代码软件，但是它的服务器是专有软件。用户可以相互交换加密与自析构的消息"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">墨染的樱花🌸</a></h3><div class="description"><p>成就今日 启迪未来</p></div></div></div><ul class="social-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>用Python写个小Bot</a></h3></div><div class="post-content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>正如你所看到的，这篇文章我们来学习一下用Python玩下Telegram中的Bot吧</p>
<p>实现一个实时查询服务器CPU利用率的Bot</p>
<blockquote>
<p>Wikipedia:</p>
<p><strong>Telegram</strong>是一个跨平台的即时通信软件，它的客户端是自由及开放源代码软件，但是它的服务器是专有软件。用户可以相互交换加密与自析构的消息，发送照片、影片等所有类型文件。官方提供手机版（Android、iOS、Windows Phone）、桌面版（Windows、macOS、Linux）和网页版等多种平台客户端；同时官方开放应用程序接口，因此拥有许多第三方的客户端可供选择，其中多款内置中文。</p>
</blockquote>
<p>Ratdis的主力即时通讯软件，个人瞎说频道 : <a href="https://t.me/xia_shuo" target="_blank" rel="noopener">链接</a></p>
<p>在这篇文章中我们使用<code>Python3</code></p>
<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="使用virtual-environment"><a href="#使用virtual-environment" class="headerlink" title="使用virtual environment"></a>使用virtual environment</h3><p>项目使用virtual environment可是个好习惯，为什么要使用这玩意呢</p>
<p>你可以简单的认为<code>virtual environment</code>是一个没有安装任何第三方库的<code>Python</code>环境，当我们写完一个项目打算分享给其他人的时候就需要告诉他这个项目用了那些第三方库，如果使用了<code>virtual environment</code>就可以很方便的找全所有使用到的第三方库了（导出方法见下文）</p>
<h4 id="本地使用"><a href="#本地使用" class="headerlink" title="本地使用"></a>本地使用</h4><p>在Pycharm中创建项目时候默认就是使用的virtual environment了</p>
<p>不用Pycharm的话，(Linux&amp;Mac)操作和服务器端是一样的</p>
<h4 id="服务器端使用"><a href="#服务器端使用" class="headerlink" title="服务器端使用"></a>服务器端使用</h4><p>先使用pip安装好virtualenv</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenv</span><br></pre></td></tr></table></figure>
<p>如果没有安装pip的，先安装pip</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br></pre></td></tr></table></figure>
<p>创建你将要使用到的项目文件夹</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir TGbot</span><br><span class="line">cd TGbot</span><br></pre></td></tr></table></figure>
<p>创建一个名为<code>venv</code>的python运行环境</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv --no-site-packages venv</span><br></pre></td></tr></table></figure>
<p>接着使用<code>source</code>进入<code>venv</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source venv/bin/activate</span><br></pre></td></tr></table></figure>
<p>不出意外的话，命令提示符最前面会多一个(venv)</p>
<h4 id="导出项目模块依赖以及安装"><a href="#导出项目模块依赖以及安装" class="headerlink" title="导出项目模块依赖以及安装"></a>导出项目模块依赖以及安装</h4><p>当你写好一个项目打算给他人使用时可以使用以下命令将项目所用到的所有模块依赖导出到requirements.txt</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>
<p>这样别人就可以直接这样安装使用啦</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>
<h3 id="安装好将要使用到的模块"><a href="#安装好将要使用到的模块" class="headerlink" title="安装好将要使用到的模块"></a>安装好将要使用到的模块</h3><p>在Pycharm中 Preferences搜索interpreter后，点加号搜索模块名称即可安装</p>
<p><img src="https://www.ratdis1.com/usr/uploads/2019/01/3127646363.png" alt="Screen Shot 2019-01-12 at 2.48.35 PM-min.png"></p>
<p>我们需要用到的模块有 <code>python-telegram-bot</code>(Telegram API)，<code>ruamel.yaml</code>(处理yaml配置文件的)，<code>psutil</code>（跨平台获取系统信息）</p>
<p>也可以直接在终端中使用安装所有</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install python-telegram-bot psutil ruamel.yaml</span><br></pre></td></tr></table></figure>
<h2 id="Telegram中的Bot介绍"><a href="#Telegram中的Bot介绍" class="headerlink" title="Telegram中的Bot介绍"></a>Telegram中的Bot介绍</h2><blockquote>
<h3 id="How-are-bots-different-from-humans"><a href="#How-are-bots-different-from-humans" class="headerlink" title="How are bots different from humans?"></a>How are bots different from humans?</h3><ul>
<li>Bots have no online status and no last seen timestamps, the interface shows the label <strong>‘bot’</strong> instead.</li>
<li>Bots have limited cloud storage — older messages may be removed by the server shortly after they have been processed.</li>
<li>Bots can’t initiate conversations with users. A user <strong>must</strong> either add them to a group or send them a message first. People can use <code>telegram.me/&lt;bot_username&gt;</code> links or username search to find your bot.</li>
<li>Bot usernames always end in ‘bot’ (e.g. <a href="https://telegram.me/triviabot" target="_blank" rel="noopener">@TriviaBot</a>, <a href="https://telegram.me/githubbot" target="_blank" rel="noopener">@GitHub_bot</a>).</li>
<li>When added to a group, bots do not receive all messages by default (see <a href="https://core.telegram.org/bots#privacy-mode" target="_blank" rel="noopener">Privacy mode</a>).</li>
<li><strong>Bots never eat, sleep or complain (unless expressly programmed otherwise).</strong></li>
</ul>
</blockquote>
<p>总之bot与真人最大差距就是没有在线状态，不能主动聊天加群以及名字结尾必须为bot，真人能做的几乎都能做，还有一些特有的功能，具体还是见<a href="https://core.telegram.org/bots" target="_blank" rel="noopener">官方介绍</a>吧</p>
<h2 id="和Botfather签订契约成为马猴烧酒Bot吧（不"><a href="#和Botfather签订契约成为马猴烧酒Bot吧（不" class="headerlink" title="和Botfather签订契约成为马猴烧酒Bot吧（不"></a>和Botfather签订契约成为马猴烧酒Bot吧（不</h2><blockquote>
<h3 id="How-do-I-create-a-bot"><a href="#How-do-I-create-a-bot" class="headerlink" title="How do I create a bot?"></a>How do I create a bot?</h3><p>There’s a… bot for that. Just talk to <a href="https://telegram.me/botfather" target="_blank" rel="noopener">BotFather</a> (described <a href="https://core.telegram.org/bots#6-botfather" target="_blank" rel="noopener">below</a>) and follow a few simple steps. Once you’ve created a bot and received your authorization token, head down to the <a href="https://core.telegram.org/bots/api" target="_blank" rel="noopener">Bot API manual</a> to see what you can teach your bot to do.</p>
</blockquote>
<p><del>就知道贴官网介绍，要你何用</del></p>
<p>跟着<a href="https://telegram.me/botfather" target="_blank" rel="noopener">BotFather</a>一顿操作就完事了</p>
<p>注意不要泄漏token</p>
<h2 id="开始吧！"><a href="#开始吧！" class="headerlink" title="开始吧！"></a>开始吧！</h2><h3 id="使用yaml处理类似于TOKEN的个人配置"><a href="#使用yaml处理类似于TOKEN的个人配置" class="headerlink" title="使用yaml处理类似于TOKEN的个人配置"></a>使用yaml处理类似于TOKEN的个人配置</h3><p>如果想让代码能够很快的为他人所用，在配置方面就应该单独的设立一个文件，可以是<code>yaml</code>也可以是<code>json</code>，这两种配置文件在<code>Python</code>中都有很好用的模块，这里我们就来使用<code>yaml</code>作为配置文件格式吧<del>（<code>json</code>中花括号太多，看着难受</del></p>
<p>由于Ratdis也是首次用到<code>yaml</code>，上<a href="https://yaml.org/" target="_blank" rel="noopener">官网</a>找到Python的模块，选了个支持最新<code>yaml</code>1.2的<a href="https://pypi.org/project/ruamel.yaml/" target="_blank" rel="noopener">ruamel.ymal</a>用着了</p>
<blockquote>
<h1 id="ruamel-yaml-Examples"><a href="#ruamel-yaml-Examples" class="headerlink" title="ruamel.yaml Examples"></a>ruamel.yaml Examples</h1><p>Basic round trip of parsing YAML to Python objects, modifying and generating YAML:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">import</span> sys</span><br><span class="line">&gt; <span class="keyword">from</span> ruamel.yaml <span class="keyword">import</span> YAML</span><br><span class="line">&gt; </span><br><span class="line">&gt; inp = <span class="string">"""\</span></span><br><span class="line"><span class="string">&gt; # example</span></span><br><span class="line"><span class="string">&gt; name:</span></span><br><span class="line"><span class="string">&gt; # details</span></span><br><span class="line"><span class="string">&gt; family: Smith   # very common</span></span><br><span class="line"><span class="string">&gt; given: Alice    # one of the siblings</span></span><br><span class="line"><span class="string">&gt; """</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; yaml = YAML()</span><br><span class="line">&gt; code = yaml.load(inp)</span><br><span class="line">&gt; code[<span class="string">'name'</span>][<span class="string">'given'</span>] = <span class="string">'Bob'</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; yaml.dump(code, sys.stdout)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Resulting in:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt; # example</span></span><br><span class="line"><span class="string">&gt; name:</span></span><br><span class="line"><span class="string">&gt; # details</span></span><br><span class="line"><span class="string">&gt; family: Smith   # very common</span></span><br><span class="line"><span class="string">&gt; given: Bob      # one of the siblings</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>想了解更多参考<a href="https://yaml.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">ruamel.yaml文档</a></p>
<p><del>其实只有一点配置也可以直接用系统的环境变量更方便…硬编码也不是不可以接受emmm</del></p>
<p>也算是学习了一种使用配置文件的方法吧</p>
<p>先在<code>config.yaml</code>里面写入</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.yaml</span></span><br><span class="line"><span class="attr">token:</span> <span class="string">你自己的token</span></span><br></pre></td></tr></table></figure>
<h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><h4 id="首先自然是导入各种模块啦"><a href="#首先自然是导入各种模块啦" class="headerlink" title="首先自然是导入各种模块啦"></a>首先自然是导入各种模块啦</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> telegram.ext <span class="keyword">import</span> Updater, CommandHandler</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> ruamel.yaml <span class="keyword">import</span> YAML</span><br><span class="line"><span class="keyword">import</span> psutil</span><br></pre></td></tr></table></figure>
<h4 id="Updater和Dispatcher"><a href="#Updater和Dispatcher" class="headerlink" title="Updater和Dispatcher"></a>Updater和Dispatcher</h4><p>接着我们需要两个类相互配合来完成bot的运作</p>
<p>一个<code>Updater</code>，另一个<code>Dispatcher</code></p>
<p>前者不断的接受来自Telegram的信息并且将这些传递到<code>Dispatcher</code>，当你创建好一个<code>Updater</code>后会自动也会创建好同属于一个队列的<code>Dispatcher</code></p>
<p>在<code>Dispatcher</code>中我们可以注册各种<code>handler</code>，这样<code>Updater</code>中的数据就会被<code>handler</code>所处理，并且将处理后的信息传递给你所指定的回调函数中去</p>
<p>所以我们这样就先读取配置文件中的<code>token</code>，并且在本地上使用代理，创建好<code>Updater</code>和<code>Dispatcher</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="comment"># 读取config.yaml配置文件</span></span><br><span class="line">yaml = YAML()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'config.yaml'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    config = yaml.load(f)</span><br><span class="line"></span><br><span class="line">TOKEN = config[<span class="string">'token'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地使用http代理,国外服务器可以不用设置</span></span><br><span class="line">REQUEST_KWARGS = &#123;</span><br><span class="line">    <span class="string">'proxy_url'</span>: <span class="string">'http://127.0.0.1:1087'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updater = Updater(TOKEN, request_kwargs=REQUEST_KWARGS)</span><br><span class="line">dispatcher = updater.dispatcher</span><br></pre></td></tr></table></figure>
<p>为了知道在此运行中出现了什么错误，我们在这里使用<code>logging</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误调试</span></span><br><span class="line">logging.basicConfig(format=<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>,</span><br><span class="line">                    level=logging.INFO)</span><br></pre></td></tr></table></figure>
<p>日常我们也可以从<code>print</code>转向<code>logging</code>来处理错误信息，<a href="https://cuiqingcai.com/6080.html" target="_blank" rel="noopener">这篇文章</a>具体的介绍了下<code>logging</code></p>
<h4 id="编写并注册回调函数"><a href="#编写并注册回调函数" class="headerlink" title="编写并注册回调函数"></a>编写并注册回调函数</h4><p>我们先来简单写个打招呼的，为了测试以上的操作是否无误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(bot, update)</span>:</span></span><br><span class="line">    bot.send_message(chat_id=update.message.chat_id, text=<span class="string">"I'm a bot"</span>)</span><br></pre></td></tr></table></figure>
<p>这个bot类型就是<code>telegram.Bot</code>，里面的各种函数参见<a href="https://python-telegram-bot.readthedocs.io/en/latest/telegram.bot.html?highlight=end_message#" target="_blank" rel="noopener">官方文档</a></p>
<p>有关send_message还是看<a href="https://core.telegram.org/bots/api#sendmessage" target="_blank" rel="noopener">文档</a>去吧</p>
<p>注册个<code>handler</code>将<code>start</code>设为回调函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_handler = CommandHandler(<span class="string">'start'</span>, start)</span><br><span class="line">dispatcher.add_handler(start_handler)</span><br></pre></td></tr></table></figure>
<p>这样写就代表当向机器人发送<code>/start</code>式就会调用start函数了</p>
<p>如果我们需要有命令参数怎么办呢，可以使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatcher.add_handler(CommandHandler(<span class="string">'start'</span>, start,pass_args=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>
<p><code>start</code>函数也需要添加个<code>agrs</code>参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(bot, update, args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args:</span><br><span class="line">        bot.send_message(chat_id=update.message.chat_id, text=<span class="string">"Hi &#123;&#125;, I'm a bot"</span>.format(args[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bot.send_message(chat_id=update.message.chat_id, text=<span class="string">"Hi , I'm a bot"</span>)</span><br></pre></td></tr></table></figure>
<p>一切都准备好后最后一行用来启动bot</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updater.start_polling()</span><br></pre></td></tr></table></figure>
<p>这样当我们使用<code>/start ratdis</code>时就会回复<code>Hi ratdis, I&#39;m a bot</code>啦</p>
<h4 id="来张嘴，吃下这颗语法糖吧-装饰器"><a href="#来张嘴，吃下这颗语法糖吧-装饰器" class="headerlink" title="来张嘴，吃下这颗语法糖吧(装饰器)"></a>来张嘴，吃下这颗语法糖吧(装饰器)</h4><p>每次都要先创建个handler再add_handler</p>
<p>我们可以使用装饰器来优化一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里我们用个装饰器来避免每个命令都需要手动注册</span></span><br><span class="line"><span class="comment"># 默认不接受命令参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span><span class="params">(handler, cmd, pass_args=False, **kw)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorater</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pass_args:</span><br><span class="line">            func_hander = handler(cmd, func, pass_args=<span class="literal">True</span>, **kw)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            func_hander = handler(cmd, func, **kw)</span><br><span class="line">        dispatcher.add_handler(func_hander)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorater</span><br></pre></td></tr></table></figure>
<p>这样我们只要在<code>start</code>函数之前加一行就完成了注册</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@command(CommandHandler, 'start', pass_args=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(bot, update, args)</span>:</span></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>一篇不错的装饰器介绍<a href="https://foofish.net/python-decorator.html" target="_blank" rel="noopener">文章</a></p>
<h4 id="使用psutil获取服务器运行信息"><a href="#使用psutil获取服务器运行信息" class="headerlink" title="使用psutil获取服务器运行信息"></a>使用psutil获取服务器运行信息</h4><p>这里我们就以获取CPU利用率为例吧</p>
<p>在这里我们使用了<code>config.yaml</code>中<code>cpu_check_times</code>和<code>cpu_check_interval</code></p>
<p>所以先将<code>config.yaml</code>改成</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">token:</span> <span class="string">你自己的token</span></span><br><span class="line"><span class="attr">cpu:</span></span><br><span class="line">  <span class="comment"># 检测CPU利用率的次数</span></span><br><span class="line"><span class="attr">  cpu_check_times:</span> <span class="number">5</span></span><br><span class="line">  <span class="comment"># 检测CPU利用率的间隔(单位为秒)</span></span><br><span class="line"><span class="attr">  cpu_check_interval:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>server</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@command(CommandHandler, 'server')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">(bot, update)</span>:</span></span><br><span class="line">    <span class="comment"># 检测CPU利用率的次数</span></span><br><span class="line">    CPU_CHECK_TIMES = config[<span class="string">'cpu'</span>][<span class="string">'cpu_check_times'</span>]</span><br><span class="line">    <span class="comment"># 检测CPU利用率的间隔(单位为秒)</span></span><br><span class="line">    CPU_CHECK_INTERVAL = config[<span class="string">'cpu'</span>][<span class="string">'cpu_check_interval'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用来保存每次检测CPU利用率的结果</span></span><br><span class="line">    cpu_check_list = [<span class="number">0</span>] * psutil.cpu_count()</span><br><span class="line">    result = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> CPU_CHECK_TIMES:</span><br><span class="line">        <span class="comment"># 检测逻辑CPU的占用率,将结果元素相加到cpu_check_list中</span></span><br><span class="line">        cpu_check_list = [a + b <span class="keyword">for</span> a, b <span class="keyword">in</span></span><br><span class="line">                          zip(psutil.cpu_percent(interval=CPU_CHECK_INTERVAL, percpu=<span class="literal">True</span>), cpu_check_list)]</span><br><span class="line">        CPU_CHECK_TIMES -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将相加结果取平均值并且转化为百分比%格式</span></span><br><span class="line">    cpu_check_list = [<span class="string">'&#123;:.2f&#125;%'</span>.format(float(x / <span class="number">10</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> cpu_check_list]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num, l <span class="keyword">in</span> enumerate(cpu_check_list):</span><br><span class="line">        result += <span class="string">"CPU&#123;&#125;平均占用&#123;&#125;\n"</span>.format(num + <span class="number">1</span>, l)</span><br><span class="line"></span><br><span class="line">    bot.send_message(chat_id=update.message.chat_id, text=result)</span><br></pre></td></tr></table></figure>
<p>这样的话，当我们输入<code>/server</code>时就会回复类似于这样的</p>
<blockquote>
<p>CPU1平均占用22.02%<br>CPU2平均占用11.65%<br>CPU3平均占用19.95%<br>CPU4平均占用11.09%</p>
</blockquote>
<p>当然psutil还提供了很多好用的函数来获取各种个样的服务器运行信息，<a href="https://psutil.readthedocs.io/en/latest/" target="_blank" rel="noopener">psutil文档</a></p>
<h2 id="本地上线到服务器"><a href="#本地上线到服务器" class="headerlink" title="本地上线到服务器"></a>本地上线到服务器</h2><p>取消代理(国外服务器)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地使用http代理</span></span><br><span class="line"><span class="comment">#REQUEST_KWARGS = &#123;</span></span><br><span class="line"><span class="comment">#    'proxy_url': 'http://127.0.0.1:1087',</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#updater = Updater(TOKEN, request_kwargs=REQUEST_KWARGS)</span></span><br><span class="line">updater = Updater(TOKEN)</span><br></pre></td></tr></table></figure>
<p>由于我们一直都是后台运行，所以需要将错误信息输出到到log文件中去，修改一下logging的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  错误调试</span></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    filename=<span class="string">'TGbot.log'</span>,</span><br><span class="line">                    datefmt=<span class="string">'%Y/%m/%d %H:%M:%S'</span>,</span><br><span class="line">                    format=<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(lineno)d - %(module)s - %(message)s'</span>)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"><span class="comment"># logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',</span></span><br><span class="line"><span class="comment">#                     level=logging.INFO)</span></span><br></pre></td></tr></table></figure>
<p>这样出错信息就可以去<code>TGbot.log</code>中去看了</p>
<p>最后使用<code>nohup</code>一直在后台运行就好啦</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python3 main.py</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次简单的写了一点关于bot的东西，还有很多特性都没有怎么说，想进一步了解的完全可以去看文档</p>
<p>这个监控bot也有很大的进步空间，大家完全可以做个全面的服务器监控Bot出来</p>
<p>利用好bot的方便性，可以很好的管理服务器，甚至是推送各类消息，推出付费功能之类的</p>
<h2 id="接下来的几个月打算"><a href="#接下来的几个月打算" class="headerlink" title="接下来的几个月打算"></a>接下来的几个月打算</h2><p>应该会有一段较长的时间不更新博文了，好好利用下假期写点小玩意，嗯，就这样吧</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-01-19</span><i class="fa fa-comment-o"></i><a href="/2019/01/19/creat-a-telegram-bot-with-python/#comments">Comments</a><i class="fa fa-tag"></i><a class="tag" href="/categories/program/" title="program">program </a><a class="tag" href="/tags/python/" title="python">python </a><a class="tag" href="/tags/telegram/" title="telegram">telegram </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://ratdis.github.io/2019/01/19/creat-a-telegram-bot-with-python/,墨染的樱花🌸,用Python写个小Bot,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/03/01/view-of-homework/" title="论作业">prev_post</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/12/18/algorithm-note-1/" title="算法笔记 壹">next_post</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'ratdis';
var disqus_identifier = '2019/01/19/creat-a-telegram-bot-with-python/';
var disqus_title = '用Python写个小Bot';
var disqus_url = 'https://ratdis.github.io/2019/01/19/creat-a-telegram-bot-with-python/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>